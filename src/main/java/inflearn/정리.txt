section 01.
naming 에 관한 내용이다.
=> skip 해도충분함
이것만은 알고가자!
이름을 뭘로지을지 고민될때 해당매서드나 함수의 기능을 주석으로 서술하고 서술된것에서 핵심단어를 뽑아서 naming 을 해주자.



section 02.
중복된 코드에 관한 내용이다.
리팩토링의 핵심이자 가장 기본이 나온다.
1. 함수추출하기
2. 관련있는 statements 들만 묶기
3. 공통된 코드는 위로 올리기
=> skip 해도충분함


section 03.
길어진 함수에 대한 내용이다.
1. 임시변수를 질의 함수로 변경하기

2. 매개변수 객체 만들기
( 매개변수들이 여러매소드에 걸쳐서 나타난다면 그 매개변수들은 자료구조,객체로 묶어줄수있다. )
( field 로 빼는 방법도 있다. )

3. 객체 통째로 넘기기
(
  여기서는 이제 getRating 을 계산하는 로직이 Participant 에 들어가게 된다.
  studyDashboard 는 participant 를 이용하여, print 로직을 출력하고있다.
  어떤 객체를 이용한다 => 의존성이 있다. => 결합도가 잇다.
  => participant 가 변경된다? => print 로직이 변경될 가능성이 있다.
  이것이 바로 결합도이다.

  응집도란 studyDashboard 와 관련된 로직만 있어야하며,
  최대한 다른 객체 및 파라미터들과 결합도가 낮아야 한다.
  말그대로 관련된 로직만! 응집해있어야한다.

  그래서 생각해볼수있다.
  participant 가 getRating 이라는 매서드를 지니고있는것이 맞는가?
  또는
  studyDashboard 에 있는것이 맞는가?

  여기서는 participant 를 넘겨주고 getRating 을 지니게함으로써
  넘겨주는 파라미터가 줄었다.
  어쩌면 getRating 의 위치는 participant 일수도있다.
  또 이런식이면 participant 가 더더 커질수있다.
  항상 고민해봐야한다.
)

4. 명령을 함수로 변경하기
print() 로직을 새로운 class 로 만들어준것이다.
해당하는 print() 로직이 다른곳에서 더 쓰일 가능성이 있고
확장가능성이있다면 이런것도 좋다.
또한 비록 new StudyPrinter().execute();
해서 해당 객체에 의존하고있지만
결합도는 낮은 상태이다 {이부분에 대해서는 좀더 정리}

5. 조건문 분해하기
사실상 얘도 함수추출하기

6. 성능보다는 리팩토링 중점!
한번의 for 문으로 전부다 하는것보다
for 문을 여러번 쪼개서 가독성을 높이는게 나을수도있다.
O(n)은 O(n)이다.

7. 조건문을 다형성으로 변환하기

section 04.
긴 파라미터 리스트에 대한 내용이다.
1. 매개변수는 짧을 수록 좋다.
함수를 호출한다는것은
함수를 호출하는 Client 가 책임을지고 매개변수를 줘야한다는말이다
=> 책임이 커진다. => 결합도가 커진다. => 의존성 up!
그러므로 매개변수가 줄어든다? => 내가 책임지고 넣어줘야할 양이 적어진다
=> 의존성이 줄어든다.로 판단될수있다
<그래도 줄인다고 항상 좋은것은 아니다. 의존성이 추가로 생길수있다.
잘 판단해보고 리팩토링할것>

2. flag_argument 없애기
플래그를 사용하는 함수는 차이를 파악하기 힘들다.
bookConcert(customer,false), bookConcert(customer,true) => 차이를 알수없다.
true,false 가 무엇을 의미? 결국, 내부구현을 살펴볼수밖에없다.
bookConcert(customer),premiumBookConcert(customer) => 아 하나는 그냥티켓 하나는 프리미엄티켓이구나.

3. section 03-04번과 매우유사하다.
여러함수과 관련이 있고 공통된 매개변수 목록을 사용한다면
해당 관련 여러함수들을 묶어서 새로운 클래스로 만들어보자.

section 05.
전역데이터
1. 변수 캡슐화 하기
Thermostats.A = "안녕"
Thermostats.B = "하이루"
이렇게 Thermostats 라는 객체안에 내부에 뭐가있는지 알고있다 => 내부구현을안다
=> 내부구현을 알아야한다. => 의존한다 => 결합도 up
그래서 캡슐화한다! => 내부구현은 모르고 의도만을 알게된다
Thermostats.setA("안녕")
Thermostats.setB("하이루")
위에가 캡슐화된것이다.
일단 이것이 기본적인 캡슐화의 개념
내부구현을 아는것이 아니라 의도를 사용한다!


section 06.
가변데이터
(데이터 변경은 자연스럽지만 이러한 데이터변경으로 인해 문제가 생길수있다.
그래서 원본은 내비두고 복사본을 주는 경우도 많다.)
1. 변수 쪼개기
어떤 변수가 여러번 재할당되어도 적절한 경우
가변하는 데이터를 하나만 선언하고 사용하는것보다
여러 변수선언으로 좀더 가독성좋게 리팩토링하자.
2. 질의 함수(select)와 변경함수(insert,update,delete) 분리하기
sideEffect 를 없애자
이는 하나의 매서드는 하나의 책임만을 져야한다랑 비슷하다.
함수형 프로그래밍의 의미를 다시금 생각해보게해주는구절
3. setter 는 제거하자.
4. 파생 변수를 질의 함수로 변경하자.
5. 여러함수를 변환 함수로 묶기
이것도 함수추출하기랑 비슷하다.
관련있는 여러 파생 변수를 만들어내는 함수가 여러곳에서 만들어지고 사용된다면
그러한 파생변수를 변환함수를 통해 한곳으로 모아둘필요가있다.
소스 데이터가 변경될가능성이 있다면 여러함수를 클래스로 묶기를 사용하는것이 적절하다.
소스데이터가 변경되지않는 경우에는 두가지 방법을 모두 사용할수있지만, 변환 함수를 사용해서 불변데이터의 필드로
생성해두고 재사용할수도있다.
6. value class 를 사용하라.


section 07.
뒤엉킨 변경
(모듈화를 잘시켜서 각 클래스,모듈,함수들은 자기일만 할수있게 변경해야된다.)
1. 단계 쪼개기 (이것도 사실상 함수 추출)
2. 함수옮기기
(
모듈화를 잘시키자.
이것도 결국 관련있는 함수는 다른 class 에 모아두고 캡슐화한다.
)
3. 클래스 추출하기
클래스가 너무많은 책임을 지니고있으면
하위클래스를 만들어서 책임을 분산시켜보는것도 고려해보자.


section 08.
산탄총 수술
(뒤엉킨 변경과 반대이다. 너무 여러곳에 흩어지면 찾기도힘들다.)
1.필드 옮기기
즉, 너무 흩어트리지말고 다시 하나로 뭉치기
2. 함수 옮기기
즉, 너무 흩어트리지말고 다시 하나로 뭉치기
3. 클래스 옮기기
즉, 너무 흩어트리지말고 다시 하나로 뭉치기

section 09.
기능 편애
어떤 모듈에 있는 함수가 다른 모듈에 있는 데이터나 함수를 더 많이 참조하는 경우에 발생한다.
=> 의존도가 너무 높다.
-> 데이터와 해당 데이터를 참조하는 행동을 같은곳에 두도록 하자.
사실 여기서 더 추가적인 리팩토링기술은없다
함수옮기기 이런것정도를 사용하여 리팩토링을 해보자.
직접 코드를 보면 이해가 쉬울듯

section 10.
데이터 뭉치
항상 뭉쳐 다니는 데이터는 한 곳으로 모아두는 것이 좋다.

section 11.
기본형 집착하지마세요.
애플리케이션이 다루고 있는 도메인에 필요한 타입을 만들지 않고 프로그래밍 언어가 제공하는 기본타입을
사용하는 경우가 많다.
ex) 전화번호,좌표,돈,범위,수량등등
1. 기본형을 객체로 바꾸기
기본형을 사용한 데이터를 감싸줄 클래스를 만들면, 필요한 기능을 추가할수있다.
2. 타입코드를 서브클래스로 변경하기
비슷하지만 다른 것들을 표기해야 하는경우, 문자열,열거형,숫자등으로 표현하기도한다.
ex) 주문타입, "일반 주문", "빠른 주문"
ex) 직원타입, "엔지니어", "매니저", "세일즈"
2-1. 상속이 될때
2-2. 상속이 안될때 (compose 전략)
3. 조건부로직을 다형성으로 바꾸기
여기서는 약간 이런개념이다.
Employee 를 만들때 new Employee("full-time", List.of("spring", "jpa")) 만들면
이 Employee 는 full-time 이라는 type 을 가지게되는데
이는 안에 field 에서 type 에 String 으로 full-time 이 있고
그에따라 조건절에 의해 동작이 달리하게되는데
이렇게 기본형으로 조건절로 동작을 달리하는것보다
따로 클래스로 만들어서 type 분류를해주고 그에따른 동작을 하는 리팩토링기법에대해서 설명하고있다.

section 12. 는 스킵

section 13.
반복문
=> 이거사실상 stream 쓰라는 이야기 modern in action 에서 더 보자.

section 14. 는 스킵

section 15. 죽은코드는 제거하라

section 16. 임시필드
특수한 경우에만 값이 들어가게나
또는 값이 변경되는 로직이 반복된다면!
이역시도 또다른 class 나 함수 등등으로 추출해낼수있다.
대표적인것이 NullObject pattern 이다.

section 17. 메시지 체인
래퍼런스를 따라 계속해서 메소드 호출이 이어지는 코드
ex) this.member.getCredit().getLevel().getDescription()
해당 코드의 클라이언트가 코드 체인을 모두 이해해야한다. => 의존성 결합도가 굉장히 높아진다.
체인중 일부가 변경된다면 클라이언트의 코드도 변경해야 한다.
1. 위임 숨기기
캡슐화란 어떤 모듈이 다른 모듈의 시스템을 최소한으로 알아야 한다는 것이다.
그래야 어떤 모듈을 변경할때, 최소한의 모듈만 그변경에 영향을 받을것이고, 그래야 무언가를 변경하기 쉽다.
person.department().manager();  -> person.getManager();
이전코드는 Department 를 통해 Manager 에 접근할수있다는 정보를 알아야하지만. (내부 구현을 알고있다.)
getManager()를 통해 위임을 숨긴다면 클라이언트는 person 의 getManager()만 알아도 된다.
나중에 getManager() 내부 구현이 변경되더라도 사용한 코드는 그대로 유지할수있다.
<결국 메시지체인을 캡슐화로 숨긴것!>

section 18. 중재자
캡슐화를 통해 내부의 구체적인 정보를 최대한 감출수있다.
그러나, 어떤 클래스의 메소드가 대부분 다른 클래스로 메소드 호출을 위임하고 있다면
중재자를 제거하고 클라이언트가 해당 클래스를 직접 사용하도록 개선할 수 있다.
즉, 나는 위에처럼 코드바로 가져다가 쓰고싶은데 위임을 숨긴애때문에
자꾸 누군가를 호출해서 가져다가쓰는 현상이 발생한다. 이게싫다.
직접가지고오고싶다 그때는 중재자를 제거하자.
1. 중재자 제거하기
위임 숨기기의 반대에 해당하는 리팩토링
필요한 캡슐화 정도는 시간에따라 그리고 상황에 따라 변화할수있다.
2. 조상상속을 위임으로 변경하기 (compose 기법이다.)
상속이 적절하지 않다고 사용될때 compose 기법을 사용해보자.
3. 자식상속 얘도 마찬가지

section 19, 내부자 거래
section 20, 거대한 클래스
앞에서 했던 section 들만 제대로이해하면 굳이필요없다.

section 21, 서로 다른 인터페이스의 대안 클래스들